{
  "_description": "PATCH pour workflow OCR - Ajouter validation DAT après Format Text",
  "_instructions": [
    "1. Ouvrir le workflow 'Accident Doc - OCR Mistral + AI Extraction'",
    "2. Déconnecter 'Format Text' de 'GEMINI Extraction' et 'OPENAI Extraction'",
    "3. Ajouter les 3 nœuds ci-dessous",
    "4. Connecter: Format Text → Validate Document → Route Validation",
    "5. Route Validation [Valid] → GEMINI + OPENAI (en parallèle)",
    "6. Route Validation [Invalid Doc] → Build Invalid Doc Error → Respond to Webhook",
    "7. Route Validation [Multiple DAT] → Build Multiple DAT Error → Respond to Webhook"
  ],

  "nodes_to_add": [
    {
      "parameters": {
        "jsCode": "// ===== VALIDATION DU DOCUMENT DAT =====\nconst extractedText = $json.extracted_text || '';\nconst textLower = extractedText.toLowerCase();\n\n// A) VÉRIFIER QUE C'EST UNE DAT\nconst DAT_KEYWORDS = [\n  { pattern: /accident\\s*(du|de)\\s*travail/i, name: 'accident du travail' },\n  { pattern: /d[ée]claration/i, name: 'déclaration' },\n  { pattern: /employeur/i, name: 'employeur' },\n  { pattern: /victime|salari[ée]/i, name: 'victime/salarié' },\n  { pattern: /cerfa|cpam|s[ée]curit[ée]\\s*sociale/i, name: 'CERFA/CPAM/Sécu' }\n];\n\nconst foundKeywords = DAT_KEYWORDS.filter(kw => kw.pattern.test(extractedText));\nconst keywordNames = foundKeywords.map(kw => kw.name);\nconst isValidDAT = foundKeywords.length >= 3;\n\n// B) DÉTECTER PLUSIEURS DAT\n// Pattern numéro de sécu: 1 ou 2 + 13 chiffres\nconst secuPattern = /[12]\\s*\\d{2}\\s*\\d{2}\\s*\\d{2}\\s*\\d{3}\\s*\\d{3}\\s*\\d{2}/g;\nconst secuMatches = extractedText.match(secuPattern) || [];\nconst uniqueSecus = [...new Set(secuMatches.map(s => s.replace(/\\s/g, '')))];\n\n// Pattern dates d'accident (format DD/MM/YYYY ou DD-MM-YYYY)\nconst dateAccidentPattern = /date\\s*(de\\s*l[''])?\\s*accident[^\\d]*(\\d{1,2}[\\/\\-]\\d{1,2}[\\/\\-]\\d{2,4})/gi;\nconst dateMatches = [];\nlet match;\nwhile ((match = dateAccidentPattern.exec(extractedText)) !== null) {\n  dateMatches.push(match[2]);\n}\nconst uniqueDates = [...new Set(dateMatches)];\n\n// Détecter plusieurs employeurs (pattern \"Employeur\" suivi de noms différents)\nconst employeurPattern = /employeur[^:]*:\\s*([^\\n,]{5,50})/gi;\nconst employeurMatches = [];\nwhile ((match = employeurPattern.exec(extractedText)) !== null) {\n  employeurMatches.push(match[1].trim().toLowerCase());\n}\nconst uniqueEmployeurs = [...new Set(employeurMatches)];\n\nconst hasMultipleDAT = uniqueSecus.length > 1 || uniqueDates.length > 1 || uniqueEmployeurs.length > 1;\nconst detectedCount = Math.max(uniqueSecus.length, uniqueDates.length, uniqueEmployeurs.length);\n\n// C) RÉSULTAT\nreturn {\n  extracted_text: extractedText,\n  validation: {\n    is_valid_dat: isValidDAT,\n    has_multiple_dat: hasMultipleDAT,\n    detected_keywords: keywordNames,\n    keyword_count: foundKeywords.length,\n    unique_secu_numbers: uniqueSecus.length,\n    unique_accident_dates: uniqueDates.length,\n    unique_employers: uniqueEmployeurs.length,\n    detected_count: detectedCount\n  },\n  // Routing flags\n  document_invalide: !isValidDAT,\n  multiple_dat: isValidDAT && hasMultipleDAT,\n  valid: isValidDAT && !hasMultipleDAT\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-4100, -200],
      "id": "validate-document-node",
      "name": "Validate Document"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.document_invalide }}",
                    "rightValue": true,
                    "operator": {
                      "type": "boolean",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Invalid Doc"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.multiple_dat }}",
                    "rightValue": true,
                    "operator": {
                      "type": "boolean",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Multiple DAT"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [-3900, -200],
      "id": "route-validation-node",
      "name": "Route Validation"
    },
    {
      "parameters": {
        "jsCode": "// Erreur: Document non valide (pas une DAT)\nconst validation = $json.validation || {};\n\nreturn {\n  success: false,\n  error_type: 'INVALID_DOCUMENT',\n  message: 'Le document uploadé ne semble pas être une déclaration d\\'accident du travail.',\n  suggestion: 'Veuillez uploader une déclaration d\\'accident du travail (CERFA 14463) ou une déclaration de maladie professionnelle.',\n  detected_keywords: validation.detected_keywords || [],\n  keyword_count: validation.keyword_count || 0,\n  minimum_required: 3\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-3700, -400],
      "id": "build-invalid-doc-error",
      "name": "Build Invalid Doc Error"
    },
    {
      "parameters": {
        "jsCode": "// Erreur: Plusieurs DAT détectées\nconst validation = $json.validation || {};\n\nreturn {\n  success: false,\n  error_type: 'MULTIPLE_DAT_DETECTED',\n  message: 'Plusieurs déclarations détectées dans votre document. Merci de n\\'uploader qu\\'UNE SEULE déclaration.',\n  detected_count: validation.detected_count || 2,\n  suggestion: 'Séparez vos documents et uploadez-les un par un.',\n  details: {\n    unique_secu_numbers: validation.unique_secu_numbers,\n    unique_accident_dates: validation.unique_accident_dates,\n    unique_employers: validation.unique_employers\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-3700, -200],
      "id": "build-multiple-dat-error",
      "name": "Build Multiple DAT Error"
    }
  ],

  "connections_to_add": {
    "Format Text": {
      "main": [[{ "node": "Validate Document", "type": "main", "index": 0 }]]
    },
    "Validate Document": {
      "main": [[{ "node": "Route Validation", "type": "main", "index": 0 }]]
    },
    "Route Validation": {
      "main": [
        [{ "node": "Build Invalid Doc Error", "type": "main", "index": 0 }],
        [{ "node": "Build Multiple DAT Error", "type": "main", "index": 0 }],
        [
          { "node": "GEMINI Extraction", "type": "main", "index": 0 },
          { "node": "OPENAI Extraction", "type": "main", "index": 0 }
        ]
      ]
    },
    "Build Invalid Doc Error": {
      "main": [[{ "node": "Respond to Webhook", "type": "main", "index": 0 }]]
    },
    "Build Multiple DAT Error": {
      "main": [[{ "node": "Respond to Webhook", "type": "main", "index": 0 }]]
    }
  }
}
